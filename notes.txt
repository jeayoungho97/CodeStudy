This study of Algorithms using C++ started on 08/Feb/2025

Date : 12/Feb/2025

    First upload to Github.

    Studied "Absorbing Markov Chain" in the morning. (MIT OCW)

    Preparing moving to a new house in the afternoon.

    moving to a new repository

    git is actually very tricky...

    experimneting with git

Date : 17/Feb/2025

    Been a tough week.. moving to a new home.

    Finally got the time to study alogithms.

    Happy to be back!

Date : 19/Feb/2025

    Solved my first BaekJoon silver problems.

    Feel like getting used to coding in c++.

    Week 0 and Week 1 studies are doing their work.

    Solving mainly Psum, Permutation, Split problems.

Date : 20/Feb/2025

    Finally free from cleaning and organizing our new home.

Date : 5/April/2025

    Finally starting week4. Haven't been leaving notes since Feb 20th but now I'll keep it on.
    -> Notes about each problem, each week and concepts.

Date : 7/April/2025

    19942 : 사전 순으로 정렬하는 것에서 틀림 -> 따로 함수를 만들어서 관리

    & 0 -> off
    & 1 -> 그대로

    | 0 -> 그대로
    | 1 -> on

    ^ 0 -> 그대로
    ^ 1 -> switch


            ...
    2 -> 000000...0010
    1 -> 000000...0001
    0 -> 000000...0000
   -1 -> 111111...1111
   -2 -> 111111...1110
            ...
    맨 앞 비트가 부호를 의미?
   -N = ~N + 1

Date : 8/April/2025

    <1285> 
    비트마스킹으로 푼 정답 코드가 왜 비트마스킹이 아닌 2차원 배열을 사용한 내 코드보다 느릴까?
    그것은 바로 비트마스킹의 범위를 N 으로 제한하지 않았기 때문 -> 제한할 경우 배열보다 더 빨라짐!
    해당 사실은 백준 - 내 제출에 가서 확인 가능.

Date : 9/April/2025

    <17471>
    비트마스킹 -> N 개의 구역을 101101.. 과 같이 표현했을 때,
    두 개의 선거구로 나눈 것이라 볼 수 있음.
    각 선거구의 구역이 서로 연결되는지 확인 -> 어떻게? 연결된 구역에 같은 선거구의 구역이 하나라도 있으면 연결된 것.
    각 선거구의 인구의 합을 서로 비교함 -> 최소값 저장

Date : 26/May/2025
    <6236>
    Main Logic : 
    1. Find minimum value of K using Binary Search
    2. 만약 M번보다 적게 돈을 인출하여 완수할 수 있다면 ok.

    Caution : 
    1. 돈이 부족한 경우 인출한 다음에 해당 arr 값을 빼줄 것!
    2. left, right 를 배열의 최댓값, 배열의 전체합으로 설정.
    3. while(left < right) 로 하고 
       true 일 경우 right = mid
       false 일 경우 left = mid + 1
       최종적으론 left 가 답이 됨.
    
    <7795>
    Main Logic (Binary Search)
    1. 각 배열 1의 값에 대해 배열 2에서 이분탐색을 이용해 더 작은 숫자의 개수를 구한다. -> O(logM)
    2. 숫자의 총합을 출력

    Main Logic (Two Pointer)
    1. 위의 방법과 비슷하나, 배열 1도 오름차순 정렬을 한 뒤 배열 2애서 점점 포인터를 늘려가며 개수를 셈. -> O(1)

    Caution
    1. 투 포인터가 훨씬 좋은 방법인듯?

    <1269>
    Main Logic
    1. 두 배열을 오름차순 정렬한 뒤 크기가 다르면 ++count, 투포인터 느낌으로 풀었
    음.

Date : 27/May/2025
    <16434>
    Main Logic
    1. Binary Search 를 이용하여 필요한 최소 hp 를 구하는 문제.
    2. 공격 후 hp 를 구할 때 직접 하나하나 계산하는게 아니라 최종 결과만 얻으면 됨. 하나하나 계산하면 시간초과.

    Caution
    1. while 문으로 계산할 경우 Big - O 를 잘 계산해야함.
    2. hp / atk 가 공격횟수가 아닌, (hp + atk - 1) / atk 가 공격횟수임을 이용해야함.

